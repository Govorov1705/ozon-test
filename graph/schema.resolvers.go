package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/Govorov1705/ozon-test/graph/model"
	"github.com/Govorov1705/ozon-test/internal/dtos"
	"github.com/Govorov1705/ozon-test/internal/errs"
	"github.com/Govorov1705/ozon-test/internal/mappers"
	"github.com/Govorov1705/ozon-test/internal/middleware"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Auth is the resolver for the auth field.
func (r *mutationResolver) Auth(ctx context.Context, input model.Auth) (*model.Jwt, error) {
	_, ok := middleware.GetUserID(ctx)
	if ok {
		return nil, &gqlerror.Error{
			Message: "You are already authenticated",
			Path:    graphql.GetPath(ctx),
		}
	}

	req := dtos.AuthRequest{
		Username: input.Username,
		Password: input.Password,
	}
	err := r.validate.Struct(&req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	token, err := r.UsersService.Auth(ctx, &req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return &model.Jwt{Token: token}, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, &gqlerror.Error{
			Message: errs.ErrUnauthenticated.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	req := dtos.CreatePostRequest{
		UserID:             userID,
		Title:              input.Title,
		Content:            input.Content,
		AreCommentsAllowed: input.AreCommentsAllowed,
	}
	err := r.validate.Struct(&req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	post, err := r.PostsService.CreatePost(ctx, &req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return mappers.ModelPostToGQL(post), nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, &gqlerror.Error{
			Message: errs.ErrUnauthenticated.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	req := dtos.CreateCommentRequest{
		PostID:  input.PostID,
		UserID:  userID,
		ReplyTo: input.ReplyTo,
		Content: input.Content,
	}
	err := r.validate.Struct(&req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	comment, err := r.CommentsService.CreateComment(ctx, &req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	GQLComment := mappers.ModelCommentToGQL(comment)

	r.CommentAddedBroadcaster.Publish(req.PostID, GQLComment)

	return GQLComment, nil
}

// DisableComments is the resolver for the disableComments field.
func (r *mutationResolver) DisableComments(ctx context.Context, postID uuid.UUID) (*model.Post, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, &gqlerror.Error{
			Message: errs.ErrUnauthenticated.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	post, err := r.PostsService.DisableComments(ctx, userID, postID)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return mappers.ModelPostToGQL(post), nil
}

// EnableComments is the resolver for the enableComments field.
func (r *mutationResolver) EnableComments(ctx context.Context, postID uuid.UUID) (*model.Post, error) {
	userID, ok := middleware.GetUserID(ctx)
	if !ok {
		return nil, &gqlerror.Error{
			Message: errs.ErrUnauthenticated.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	post, err := r.PostsService.EnableComments(ctx, userID, postID)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return mappers.ModelPostToGQL(post), nil
}

// GetPosts is the resolver for the getPosts field.
func (r *queryResolver) GetPosts(ctx context.Context) ([]*model.Post, error) {
	posts, err := r.PostsService.GetAllPosts(ctx)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return mappers.ModelPostsToGQL(posts), nil
}

// GetPostWithComments is the resolver for the getPostWithComments field.
func (r *queryResolver) GetPostWithComments(ctx context.Context, postID uuid.UUID, limit *int32, offset *int32) (*model.PostWithComments, error) {
	req := dtos.GetPostWithCommentsRequest{
		PostID: postID,
		Limit:  limit,
		Offset: offset,
	}
	err := r.validate.Struct(&req)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	postWithComments, err := r.PostsService.GetPostWithComments(ctx, postID, limit, offset)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: err.Error(),
			Path:    graphql.GetPath(ctx),
		}
	}

	return mappers.DTOPostWithCommentsToGQL(postWithComments), nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID uuid.UUID) (<-chan *model.Comment, error) {
	ch := r.CommentAddedBroadcaster.Subscribe(postID)

	go func() {
		<-ctx.Done()
		r.CommentAddedBroadcaster.Unsubscribe(postID, ch)
	}()

	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
